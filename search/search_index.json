{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"pytket-custatevec <p>GPU-accelerated statevector and shot-based simulation for pytket.</p> Get Started View Examples <p><code>pytket-custatevec</code> acts as an open-source bridge between Quantinuum's pytket compiler and NVIDIA's cuQuantum SDK, enabling massive speedups for circuit simulations.</p>"},{"location":"#why-use-this-backend","title":"Why use this backend?","text":"<ul> <li> <p> High Performance     ---     Leverage NVIDIA GPUs to enable rapid simulation of quantum circuits using parallel architecture.</p> </li> <li> <p> Seamless Integration     ---     Works as a standard <code>pytket</code> Backend. Just switch your backend import, and your existing code runs on the GPU immediately.</p> </li> <li> <p> Optimized Memory     ---     Utilizes <code>cuStateVec</code>'s advanced memory management to handle large statevectors efficiently on GPU VRAM.</p> </li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>This library sits directly on top of the NVIDIA cuQuantum stack.</p> flowchart LR     %% Node Definitions     User([User Code])     Backend[CuStateVecBackend]     SDK[NVIDIA cuStateVec]     GPU[NVIDIA GPU]      %% Connections     User == pytket Circuit ==&gt; Backend     Backend == cuQuantum Python ==&gt; SDK     SDK -.-&gt; |CUDA| GPU      %% Assign Classes (CSS will handle the colors)     class User user;     class Backend pytket;     class SDK nvidia;     class GPU hardware;"},{"location":"#bugs-and-support","title":"Bugs and Support","text":"<p>This is a community-driven project. Please file bugs and feature requests on the GitHub Issue Tracker.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>The following benchmarks demonstrate the performance of the <code>pytket-custatevec</code> backend compared to other statevector simulators within the pytket ecosystem.</p> <p>Comparison Scope</p> <p>These tests compare <code>pytket-custatevec</code> against <code>pytket-qiskit</code> and <code>pytket-qulacs</code>.</p> <p>All simulations are performed via the abstract <code>pytket</code> Backend interface to demonstrate the speedup available to users simply by switching their backend instance.</p>"},{"location":"benchmarks/#methodology","title":"Methodology","text":""},{"location":"benchmarks/#the-circuit","title":"The Circuit","text":"<p>We use a Random Line Circuit to ensure a fair stress test. This structure creates a highly entangled state that is difficult to simplify or optimize trivially.</p> <ul> <li>Structure: Linear connectivity (1D chain).</li> <li>Depth: Fixed at 10 layers.</li> <li>Gates: Random <code>TK1</code> (single qubit) gates followed by <code>CX</code> (two-qubit) gates between neighbors.</li> </ul> <pre><code>def random_line_circuit(n_qubits: int, layers: int) -&gt; Circuit:\n    c = Circuit(n_qubits)\n    for i in range(layers):\n        # 1. Random Single Qubit Rotations\n        for q in range(n_qubits):\n            c.TK1(np.random.rand(), np.random.rand(), np.random.rand(), q)\n\n        # 2. Linear Entanglement (Alternating Even/Odd links)\n        offset = np.mod(i, 2)\n        qubit_pairs = [[c.qubits[i], c.qubits[i+1]] for i in range(offset, n_qubits-1, 2)]\n\n        for pair in qubit_pairs:\n            c.CX(pair[0], pair[1])\n    return c\n</code></pre>"},{"location":"benchmarks/#1-statevector-simulation","title":"1. Statevector Simulation","text":"<p>This benchmark measures the time required to calculate the full statevector (\\(2^n\\) complex amplitudes).</p>"},{"location":"benchmarks/#2-shot-based-sampling","title":"2. Shot-based Sampling","text":"<p>This benchmark measures the time to simulate measurement outcomes (1000 shots) for the same random circuits.</p>"},{"location":"benchmarks/#environment","title":"Environment","text":"<p>The results above were auto-generated by our CI pipeline using the following environment:</p> Component Specification / Version GPU Tesla T4 CPU Intel(R) Xeon(R) Platinum 8259CL CPU @ 2.50GHz Python 3.12.11 OS Linux 6.8.0-1024-aws pytket 2.11.0 pytket-custatevec 0.0.1 pytket-qulacs 0.41.0 pytket-qiskit 0.74.0 cuquantum-python N/A"},{"location":"benchmarks/#reproduce-this-benchmark","title":"Reproduce this Benchmark","text":"<p>You can find the source code for these benchmarks in our repository:</p> <p> View Benchmark Script</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#development","title":"Development","text":"<p>To install an extension in editable mode, from its root folder run:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Pull requests are welcome. To make a PR, first fork the repo, make your proposed changes on the <code>main</code> branch, and open a PR from your fork. If it passes tests and is accepted after review, it will be merged in.</p>"},{"location":"contributing/#code-style","title":"Code style","text":"<p>Code style can be checked locally using pre-commit hooks; run pre-commit before committing your changes and opening a pull request by executing:</p> <pre><code>pre-commit run\n</code></pre> <p>This will automatically:</p> <ul> <li>Format code using ruff with default options.</li> <li>Do static type checking using mypy.</li> <li>Lint using ruff to check compliance with a set of style requirements (listed in <code>ruff.toml</code>).</li> </ul> <p>Compliance with the above checks is checked by continuous integration before a pull request can be merged.</p>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>We use the Google style docstrings, please see this page for reference.</p>"},{"location":"contributing/#tests","title":"Tests","text":"<p>To run the tests for a module:</p> <pre><code>pip install \"pytket-custatevec[test]\"\npytest tests/\n</code></pre> <p>When adding a new feature, please add a test for it. When fixing a bug, please add a test that demonstrates the fix.</p>"},{"location":"gates/","title":"Supported Gates","text":"<p><code>pytket-custatevec</code> natively implements the following unitary gates using NVIDIA's <code>cuStateVec</code> kernels.</p>"},{"location":"gates/#single-qubit-gates","title":"Single Qubit Gates","text":"Gate Symbol Matrix Representation I \\(I\\) \\(\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{bmatrix}\\) X \\(X\\) \\(\\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}\\) Y \\(Y\\) \\(\\begin{bmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{bmatrix}\\) Z \\(Z\\) \\(\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{bmatrix}\\) H \\(H\\) \\(\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\end{bmatrix}\\) S \\(S\\) \\(\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; i \\end{bmatrix}\\) Sdg \\(S^\\dagger\\) \\(\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; -i \\end{bmatrix}\\) T \\(T\\) \\(\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\pi/4} \\end{bmatrix}\\) V / SX \\(\\sqrt{X}\\) \\(\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 &amp; -i \\\\ -i &amp; 1 \\end{bmatrix}\\)"},{"location":"gates/#parameterized-single-qubit","title":"Parameterized Single Qubit","text":"Gate Definition Matrix Form Rx \\(R_x(\\theta)\\) \\(\\begin{bmatrix} \\cos\\frac{\\theta}{2} &amp; -i\\sin\\frac{\\theta}{2} \\\\ -i\\sin\\frac{\\theta}{2} &amp; \\cos\\frac{\\theta}{2} \\end{bmatrix}\\) Ry \\(R_y(\\theta)\\) \\(\\begin{bmatrix} \\cos\\frac{\\theta}{2} &amp; -\\sin\\frac{\\theta}{2} \\\\ \\sin\\frac{\\theta}{2} &amp; \\cos\\frac{\\theta}{2} \\end{bmatrix}\\) Rz \\(R_z(\\theta)\\) \\(\\begin{bmatrix} e^{-i\\theta/2} &amp; 0 \\\\ 0 &amp; e^{i\\theta/2} \\end{bmatrix}\\) U1 \\(U1(\\lambda)\\) \\(\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\lambda} \\end{bmatrix}\\) U3 \\(U3(\\theta, \\phi, \\lambda)\\) \\(\\begin{bmatrix} \\cos\\frac{\\theta}{2} &amp; -e^{i\\lambda}\\sin\\frac{\\theta}{2} \\\\ e^{i\\phi}\\sin\\frac{\\theta}{2} &amp; e^{i(\\phi+\\lambda)}\\cos\\frac{\\theta}{2} \\end{bmatrix}\\) PhasedX \\(R_x(\\theta, \\phi)\\) \\(R_z(\\phi) R_x(\\theta) R_z(-\\phi)\\) TK1 \\(TK1(\\alpha, \\beta, \\gamma)\\) \\(R_z(\\alpha) R_x(\\beta) R_z(\\gamma)\\)"},{"location":"gates/#two-qubit-gates","title":"Two Qubit Gates","text":"Gate Description Matrix / definition SWAP Swap states \\(\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}\\) ECR Echoed Cross-Resonance \\(\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; i \\\\ 0 &amp; 0 &amp; i &amp; 1 \\\\ 1 &amp; -i &amp; 0 &amp; 0 \\\\ -i &amp; 1 &amp; 0 &amp; 0 \\end{bmatrix}\\) ZZMax Maximal Entanglement \\(e^{-i \\frac{\\pi}{4} Z \\otimes Z} = \\text{diag}(e^{-i\\pi/4}, e^{i\\pi/4}, e^{i\\pi/4}, e^{-i\\pi/4})\\) XXPhase Ising XX \\(e^{-i \\frac{\\theta}{2} X \\otimes X}\\) YYPhase Ising YY \\(e^{-i \\frac{\\theta}{2} Y \\otimes Y}\\) ZZPhase Ising ZZ \\(e^{-i \\frac{\\theta}{2} Z \\otimes Z}\\) ISWAP Swap + Phase \\(\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; c &amp; i s &amp; 0 \\\\ 0 &amp; i s &amp; c &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}, \\small{c=\\cos(\\frac{\\theta}{2}), s=\\sin(\\frac{\\theta}{2})}\\)"},{"location":"gates/#controlled-gates","title":"Controlled Gates","text":"<p>Standard controlled gates are supported. The backend handles the control logic natively.</p> Gate Description CX, CY, CZ Controlled Pauli gates CH, CV, CS, CSX Controlled Clifford gates CCX (Toffoli) Doubly-Controlled X CSWAP (Fredkin) Controlled SWAP CRx, CRy, CRz Controlled Rotations CU1, CU3 Controlled Unitaries"},{"location":"installation/","title":"Installation","text":"<p><code>pytket-custatevec</code> requires Python 3.10+ and a Linux machine with an NVIDIA GPU (Compute Capability 7.0+).</p> <p>Prerequisites</p> <p>Ensure your machine has the NVIDIA Drivers installed and working (check with <code>nvidia-smi</code>).</p> <p>You generally do not need to install the full CUDA Toolkit system package, as the Python packages below include the necessary runtime libraries.</p>"},{"location":"installation/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Select your package manager to install the required libraries.</p> Conda (Recommended)Pip <p>We recommend Conda because it reliably manages the system-level CUDA libraries alongside Python packages.</p> <pre><code># 1. Install NVIDIA libraries\nconda install -c conda-forge cuquantum-python\n\n# 2. Install the package\npip install pytket-custatevec\n</code></pre> <p>You can install everything via pip. This will automatically download the binary wheels for <code>cuquantum</code> and <code>cupy</code>.</p> <pre><code>pip install pytket-custatevec\n</code></pre> <p>Linux Requirements</p> <p>If you see <code>ImportError: libcustatevec.so not found</code>, ensure you have a recent version of <code>pip</code> (<code>pip install --upgrade pip</code>) and a compatible Linux distribution (glibc 2.17+).</p>"},{"location":"installation/#2-verify-installation","title":"2. Verify Installation","text":"<p>You can check if the backend loads correctly by running this one-liner:</p> <pre><code>python -c \"from pytket.extensions.custatevec import CuStateVecStateBackend; print('\u2705 Backend loaded successfully')\"\n</code></pre>"},{"location":"people/","title":"People","text":"<p><code>pytket-custatevec</code> is developed and maintained by the Quantinuum team and our amazing community of contributors.</p>"},{"location":"people/#maintainers","title":"Maintainers","text":"<p>The current maintainers of the <code>pytket-custatevec</code> repository.</p> @Fabian Finger @Gabriel Matos @Pranav Kalidindi @Jake Arkinstall"},{"location":"people/#acknowledgments","title":"Acknowledgments","text":"<p>Special thanks to the NVIDIA cuQuantum team for their support and the underlying library that makes this backend possible.</p> <p>Contribute</p> <p>Want to see your face here? We welcome contributions! Check out our Contributing Guidelines to get started.</p>"},{"location":"api/","title":"API Reference","text":"<p>The <code>pytket-custatevec</code> package provides high-performance GPU backends for simulating quantum circuits.</p>"},{"location":"api/#available-backends","title":"Available Backends","text":"<ul> <li> <p> Statevector Backend     ---     Calculates the exact quantum state vector (\\(2^n\\) amplitudes). Ideal for theoretical validation and calculating exact expectation values.</p> <p> Read Docs</p> </li> <li> <p> Shots Backend     ---     Simulates measurement sampling (shots). Use this to mimic the behavior of a real QPU or to test probabilistic algorithms.</p> <p> Read Docs</p> </li> </ul>"},{"location":"api/#comparison","title":"Comparison","text":"<p>Not sure which backend to use?</p> Feature <code>CuStateVecStateBackend</code> <code>CuStateVecShotsBackend</code> Output Full Statevector (<code>np.ndarray</code>) Measurement Counts (<code>dict</code>) Memory Usage High (scales exponentially \\(2^n\\)) High (internal statevector) Primary Use Debugging, Exact Expectations Sampling, QPU Emulation Basis Order Supports ILO &amp; DLO Supports ILO &amp; DLO Noise Ideal (Noise-free) Shot Noise (Sampling error)"},{"location":"api/#common-functionality","title":"Common Functionality","text":"<p>Both backends inherit from the <code>pytket</code> <code>Backend</code> class and support:</p> <ul> <li>Compilation: <code>get_compiled_circuit(circ)</code> handles implicit swaps and gate decomposition automatically.</li> <li>GPU Acceleration: Both utilize NVIDIA cuStateVec to accelerate tensor operations.</li> <li>Context Management: Both handle GPU memory resources efficiently.</li> </ul> <p>Performance Note</p> <p>For circuits with more than 30 qubits, ensure your GPU has sufficient VRAM. The statevector size doubles with every additional qubit.</p>"},{"location":"api/shots_backend/","title":"Shots Backend","text":""},{"location":"api/shots_backend/#pytket.extensions.custatevec.backends.CuStateVecShotsBackend","title":"<code>CuStateVecShotsBackend()</code>","text":"<p>A pytket Backend using <code>GeneralState</code> to obtain shots.</p> <p>Constructs a new cuStateVec backend object.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Constructs a new cuStateVec backend object.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"api/shots_backend/#pytket.extensions.custatevec.backends.CuStateVecShotsBackend.backend_info","title":"<code>backend_info</code>  <code>property</code>","text":"<p>Returns information on the backend.</p>"},{"location":"api/shots_backend/#pytket.extensions.custatevec.backends.CuStateVecShotsBackend.process_circuit","title":"<code>process_circuit(circuit, n_shots=None, valid_check=True, **kwargs)</code>","text":"<p>Submits circuits to the backend for running.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def process_circuit(\n    self,\n    circuit: Circuit,\n    n_shots: int | None = None,\n    valid_check: bool = True,\n    **kwargs: KwargTypes,\n) -&gt; ResultHandle:\n    \"\"\"Submits circuits to the backend for running.\"\"\"\n    return self.process_circuits(\n        [circuit],\n        n_shots=n_shots,\n        valid_check=valid_check,\n        **kwargs,\n    )[0]\n</code></pre>"},{"location":"api/shots_backend/#pytket.extensions.custatevec.backends.CuStateVecShotsBackend.process_circuits","title":"<code>process_circuits(circuits, n_shots=None, valid_check=True, **kwargs)</code>","text":"<p>Submits circuits to the backend for running and returns result handles.</p> <p>Parameters:</p> Name Type Description Default <code>circuits</code> <code>Sequence[Circuit]</code> <p>List of circuits to be submitted.</p> required <code>n_shots</code> <code>int | Sequence[int] | None</code> <p>Number of shots for shot-based calculation.</p> <code>None</code> <code>valid_check</code> <code>bool</code> <p>Whether to check for circuit correctness.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ResultHandle]</code> <p>List of result handles for the submitted circuits.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def process_circuits(  # noqa: D417\n    self,\n    circuits: Sequence[Circuit],\n    n_shots: int | Sequence[int] | None = None,\n    valid_check: bool = True,\n    **kwargs: KwargTypes,\n) -&gt; list[ResultHandle]:\n    \"\"\"Submits circuits to the backend for running and returns result handles.\n\n    Args:\n        circuits: List of circuits to be submitted.\n        n_shots: Number of shots for shot-based calculation.\n        valid_check: Whether to check for circuit correctness.\n\n    Returns:\n        List of result handles for the submitted circuits.\n    \"\"\"\n    if n_shots is None:\n        raise ValueError(\"n_shots must be specified for shot-based simulation.\")\n\n    all_shots = [n_shots] * len(circuits) if isinstance(n_shots, int) else n_shots\n\n    if valid_check:\n        self._check_all_circuits(circuits, nomeasure_warn=False)\n\n    handle_list = []\n    for circuit, circ_shots in zip(circuits, all_shots, strict=False):\n        with CuStateVecHandle() as libhandle:\n            sv = initial_statevector(\n                handle=libhandle,\n                n_qubits=circuit.n_qubits,\n                sv_type=\"zero\",\n                dtype=cudaDataType.CUDA_C_64F,\n            )\n            run_circuit(libhandle, circuit, sv)\n\n            # IMPORTANT: _qubit_idx_map matches cuStateVec's little-endian convention\n            # (qubit 0 = least significant) with pytket's big-endian (qubit 0 = most significant).\n            # Now all operations by the cuStateVec library will be in the correct order.\n            _qubit_idx_map: dict[Qubit, int] = {q: i for i, q in enumerate(sorted(circuit.qubits, reverse=True))}\n            # Get relabeled qubit indices that will be measured\n            measured_qubits = [_qubit_idx_map[x] for x in circuit.qubit_readout]\n            # IMPORTANT: After relabling with _qubit_idx_map, cuStateVec.sampler_sample function still\n            # requires its list of measured qubits to be in the LSB-to-MSB order.\n            # This reversal adapts our MSB-first list to the LSB-first format cuStateVec requires.\n            measured_qubits.reverse()\n\n            sampler_descriptor, size_t = cusv.sampler_create(  # type: ignore[no-untyped-call]\n                handle=libhandle.handle,\n                sv=sv.array.data.ptr,\n                sv_data_type=cudaDataType.CUDA_C_64F,\n                n_index_bits=sv.n_qubits,\n                n_max_shots=circ_shots,\n            )\n\n            bit_strings_int64 = np.empty((circ_shots, 1), dtype=np.int64)  # needs to be int64\n\n            # Generate random numbers for sampling\n            seed = kwargs.get(\"seed\")\n            rng = np.random.default_rng(seed)\n            randnums = np.atleast_1d(rng.random(circ_shots, dtype=np.float64)).tolist()\n\n            cusv.sampler_preprocess(  # type: ignore[no-untyped-call]\n                handle=libhandle.handle,\n                sampler=sampler_descriptor,\n                extra_workspace=0,\n                extra_workspace_size_in_bytes=0,\n            )\n\n            cusv.sampler_sample(  # type: ignore[no-untyped-call]\n                handle=libhandle.handle,\n                sampler=sampler_descriptor,\n                bit_strings=bit_strings_int64.ctypes.data,\n                bit_ordering=measured_qubits,\n                bit_string_len=len(measured_qubits),\n                randnums=randnums,\n                n_shots=n_shots,\n                output=SamplerOutput.RANDNUM_ORDER,\n            )\n\n            cusv.sampler_destroy(sampler_descriptor)  # type: ignore[no-untyped-call]\n\n        handle = ResultHandle(str(uuid4()))\n\n        # Reformat bit_strings from list of 64-bit signed integer (memory-efficient\n        # way for custatevec to save many shots) to list of binaries for OutcomeArray\n        bit_strings_binary = [format(s, f\"0{len(measured_qubits)}b\") for s in bit_strings_int64.flatten().tolist()]\n        bit_strings_binary = [tuple(map(int, binary)) for binary in bit_strings_binary]  # type: ignore[misc]\n\n        # In order to be able to use the BackendResult functionality,\n        # we only pass the array of the statevector to BackendResult\n        self._cache[handle] = {\n            \"result\": BackendResult(\n                state=cp.asnumpy(sv.array),\n                shots=OutcomeArray.from_readouts(bit_strings_binary),\n            ),\n        }\n        handle_list.append(handle)\n    return handle_list\n</code></pre>"},{"location":"api/state_backend/","title":"Statevector Backend","text":""},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend","title":"<code>CuStateVecStateBackend()</code>","text":"<p>A pytket Backend using <code>GeneralState</code> to obtain state vectors.</p> <p>Constructs a new cuStateVec backend object.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Constructs a new cuStateVec backend object.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend.backend_info","title":"<code>backend_info</code>  <code>property</code>","text":"<p>Returns information on the backend.</p>"},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend.get_operator_expectation_value","title":"<code>get_operator_expectation_value(circuit, operator)</code>","text":"<p>Calculate the expectation value of a QubitPauliOperator given a quantum state prepared by a circuit.</p> <p>This method computes the expectation value of a specified operator with respect to the quantum state generated by the provided state preparation circuit. It leverages cuStateVec for efficient statevector simulation and expectation value computation.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit that prepares the desired quantum state.</p> required <code>operator</code> <code>QubitPauliOperator</code> <p>The operator for which the expectation value is to be calculated.</p> required <p>Returns:</p> Type Description <code>float64</code> <p>np.float64: The computed expectation value of the operator with respect to</p> <code>float64</code> <p>the quantum state.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def get_operator_expectation_value(\n    self,\n    circuit: Circuit,\n    operator: QubitPauliOperator,\n) -&gt; np.float64:\n    \"\"\"Calculate the expectation value of a QubitPauliOperator given a quantum state prepared by a circuit.\n\n    This method computes the expectation value of a specified operator with respect\n    to the quantum state generated by the provided state preparation circuit. It\n    leverages cuStateVec for efficient statevector simulation and expectation value\n    computation.\n\n    Args:\n        circuit (Circuit): The quantum circuit that prepares the desired\n            quantum state.\n        operator (QubitPauliOperator): The operator for which the expectation value\n            is to be calculated.\n\n    Returns:\n        np.float64: The computed expectation value of the operator with respect to\n        the quantum state.\n    \"\"\"\n    with CuStateVecHandle() as libhandle:\n        sv = initial_statevector(\n            handle=libhandle,\n            n_qubits=circuit.n_qubits,\n            sv_type=\"zero\",\n            dtype=cudaDataType.CUDA_C_64F,\n        )\n        run_circuit(libhandle, circuit, sv)\n        return compute_expectation(libhandle, sv, operator, circuit)\n</code></pre>"},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend.process_circuit","title":"<code>process_circuit(circuit, n_shots=None, valid_check=True, **kwargs)</code>","text":"<p>Submits circuits to the backend for running.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def process_circuit(\n    self,\n    circuit: Circuit,\n    n_shots: int | None = None,\n    valid_check: bool = True,\n    **kwargs: KwargTypes,\n) -&gt; ResultHandle:\n    \"\"\"Submits circuits to the backend for running.\"\"\"\n    return self.process_circuits(\n        [circuit],\n        n_shots=n_shots,\n        valid_check=valid_check,\n        **kwargs,\n    )[0]\n</code></pre>"},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend.process_circuits","title":"<code>process_circuits(circuits, n_shots=None, valid_check=True, **kwargs)</code>","text":"<p>Submits circuits to the backend for running.</p> <p>The results will be stored in the backend's result cache to be retrieved by the corresponding get_ method. <p>Parameters:</p> Name Type Description Default <code>circuits</code> <code>Sequence[Circuit]</code> <p>List of circuits to be submitted.</p> required <code>n_shots</code> <code>int | Sequence[int] | None</code> <p>Number of shots in case of shot-based calculation. This is unused, since this backend does not support shots.</p> <code>None</code> <code>valid_check</code> <code>bool</code> <p>Whether to check for circuit correctness.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ResultHandle]</code> <p>Results handle objects.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def process_circuits(  # noqa: D417\n    self,\n    circuits: Sequence[Circuit],\n    n_shots: int | Sequence[int] | None = None,  # noqa: ARG002\n    valid_check: bool = True,\n    **kwargs: KwargTypes,  # noqa: ARG002\n) -&gt; list[ResultHandle]:\n    \"\"\"Submits circuits to the backend for running.\n\n    The results will be stored in the backend's result cache to be retrieved by the\n    corresponding get_&lt;data&gt; method.\n\n    Args:\n        circuits: List of circuits to be submitted.\n        n_shots: Number of shots in case of shot-based calculation.\n            This is unused, since this backend does not support shots.\n        valid_check: Whether to check for circuit correctness.\n\n    Returns:\n        Results handle objects.\n    \"\"\"\n    if valid_check:\n        self._check_all_circuits(circuits, nomeasure_warn=False)\n\n    handle_list = []\n    for circuit in circuits:\n        with CuStateVecHandle() as libhandle:\n            sv = initial_statevector(\n                handle=libhandle,\n                n_qubits=circuit.n_qubits,\n                sv_type=\"zero\",\n                dtype=cudaDataType.CUDA_C_64F,\n            )\n            run_circuit(libhandle, circuit, sv)\n        handle = ResultHandle(str(uuid4()))\n        # In order to be able to use the BackendResult functionality,\n        # we only pass the array of the statevector to BackendResult\n        self._cache[handle] = {\"result\": BackendResult(state=cp.asnumpy(sv.array))}\n        handle_list.append(handle)\n    return handle_list\n</code></pre>"},{"location":"assets/benchmark_env/","title":"Benchmark env","text":"Component Specification / Version GPU Tesla T4 CPU Intel(R) Xeon(R) Platinum 8259CL CPU @ 2.50GHz Python 3.12.11 OS Linux 6.8.0-1024-aws pytket 2.11.0 pytket-custatevec 0.0.1 pytket-qulacs 0.41.0 pytket-qiskit 0.74.0 cuquantum-python N/A"},{"location":"examples/","title":"Examples Overview","text":"<p>Explore common usage patterns for <code>pytket-custatevec</code>.</p> <ul> <li> <p> Basic Simulation     ---     Learn how to run statevector simulations and shot-based sampling. Calculate expectation values efficiently and handle specific basis ordering.</p> <p> Read More</p> </li> <li> <p> Benchmarks     ---     View live performance comparisons against CPU simulators (up to \\(10\\times\\) speedups).</p> <p> See Results</p> </li> </ul>"},{"location":"examples/simulation/","title":"Simulation Examples","text":""},{"location":"examples/simulation/#statevector-simulation","title":"Statevector Simulation","text":"<p>The <code>CuStateVecStateBackend</code> allows you to retrieve the full statevector of a quantum circuit. This example simulates a Bell State (\\(|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\\)).</p> <pre><code>import numpy as np\nfrom pytket import Circuit\nfrom pytket.extensions.custatevec import CuStateVecStateBackend\n\n# 1. Define a Bell State circuit\ncirc = Circuit(2)\ncirc.H(0).CX(0, 1)\n\n# 2. Initialize the Statevector Backend\nbackend = CuStateVecStateBackend()\n\n# 3. Compile the circuit for the backend\ncompiled_circ = backend.get_compiled_circuit(circ)\n\n# 4. Run and retrieve the statevector\nhandle = backend.process_circuit(compiled_circ)\nresult = backend.get_result(handle)\nstatevector = result.get_state()\n\nprint(\"Statevector:\", np.round(statevector, 3))\n</code></pre>"},{"location":"examples/simulation/#shot-based-sampling","title":"Shot-based Sampling","text":"<p>The <code>CuStateVecShotsBackend</code> mimics a quantum computer by returning measurement counts.</p> <pre><code>from pytket import Circuit\nfrom pytket.extensions.custatevec import CuStateVecShotsBackend\n\n# 1. Define a circuit with measurements\ncirc = Circuit(2, 2)\ncirc.H(0).CX(0, 1)\ncirc.measure_all()\n\n# 2. Initialize the Shots Backend\nbackend = CuStateVecShotsBackend()\ncompiled_circ = backend.get_compiled_circuit(circ)\n\n# 3. Run with a specific number of shots\nhandle = backend.process_circuit(compiled_circ, n_shots=1000)\nresult = backend.get_result(handle)\n\n# 4. Get counts\ncounts = result.get_counts()\nprint(\"Counts:\", counts)\n</code></pre>"},{"location":"examples/simulation/#calculating-expectation-values","title":"Calculating Expectation Values","text":"<p>You can calculate operator expectation values efficiently on the GPU without explicitly retrieving the full statevector.</p> <pre><code>from pytket import Circuit, Qubit\nfrom pytket.pauli import Pauli, QubitPauliString\nfrom pytket.utils.operators import QubitPauliOperator\nfrom pytket.utils.expectations import get_operator_expectation_value\nfrom pytket.extensions.custatevec import CuStateVecStateBackend\n\n# 1. Define a circuit\ncirc = Circuit(2)\ncirc.H(0).CX(0, 1)  # Bell state\n\n# 2. Define an operator (e.g., Z0 * Z1)\nop = QubitPauliOperator({\n    QubitPauliString([Qubit(0), Qubit(1)], [Pauli.Z, Pauli.Z]): 1.0\n})\n\n# 3. Calculate expectation value\nbackend = CuStateVecStateBackend()\nexpectation = get_operator_expectation_value(circ, op, backend)\n\nprint(f\"Expectation value &lt;Z0 Z1&gt;: {expectation}\")\n</code></pre>"},{"location":"examples/simulation/#basis-order","title":"Basis Order","text":"<p>By default, pytket uses ilo (Increasing Lexicographic Order). You can explicitly request dlo (Decreasing Lexicographic Order/Big Endian).</p> <pre><code>from pytket import Circuit, BasisOrder\nfrom pytket.extensions.custatevec import CuStateVecStateBackend\n\n# Create state |01&gt; (qubit 0 is 0, qubit 1 is 1)\ncirc = Circuit(2).X(1)\n\nbackend = CuStateVecStateBackend()\ncompiled_circ = backend.get_compiled_circuit(circ)\nresult = backend.run_circuit(compiled_circ)\n\n# pytket default (Little Endian): |01&gt; corresponds to index 2 (binary 10 reversed)\nprint(\"ILO (Default):\", result.get_state(basis=BasisOrder.ilo))\n\n# Big Endian: |01&gt; corresponds to index 1 (binary 01)\nprint(\"DLO:\", result.get_state(basis=BasisOrder.dlo))\n</code></pre>"}]}